package boaconstructor

import (
	"strings"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/dialog"
	"fyne.io/fyne/v2/widget"
	"github.com/westarver/boa"
)

func confirmGen() {
	source := "Main"
	message :=
		`Boa will now attempt to write the source file ` + source + `
to the path you choose. Boa suggests using the filenames            
'main.go', 'runner.go', and 'help.go', but any names can be used   `
	dialog.ShowCustomConfirm("Confirm code generation for Main", "Write Main", "Cancel", widget.NewLabel(message), generateMain, appData.mainWindow)

	source = "Run"
	message =
		`Boa will now attempt to write the source file ` + source + `
to the path you choose. Boa suggests using the filenames            
'main.go', 'runner.go', and 'help.go', but any names can be used   `
	dialog.ShowCustomConfirm("Confirm code generation for Run", "Write Run", "Cancel", widget.NewLabel(message), generateRun, appData.mainWindow)

	source = "Help"
	message =
		`Boa will now attempt to write the source file ` + source + `
to the path you choose. Boa suggests using the filenames            
'main.go', 'runner.go', and 'help.go', but any names can be used   `

	dialog.ShowCustomConfirm("Confirm code generation for Help", "Write Help", "Cancel", widget.NewLabel(message), generateHelp, appData.mainWindow)

}

func generateMain(y bool) {
	if y {
		dialog.ShowFileSave(writeMain, appData.mainWindow)
	}
}

func generateRun(y bool) {
	if y {
		dialog.ShowFileSave(writeRunner, appData.mainWindow)
	}
}

func generateHelp(y bool) {
	if y {
		dialog.ShowFileSave(writeHelp, appData.mainWindow)
	}
}

func writeMain(uwc fyne.URIWriteCloser, e error) {
	main_go := main_go()

	if uwc == nil {
		return
	}
	defer uwc.Close()
	if e != nil {
		dlg := dialog.NewError(e, appData.mainWindow)
		dlg.Show()
	}
	uwc.Write([]byte(main_go))
}

func writeRunner(uwc fyne.URIWriteCloser, e error) {
	runner_go := runner_go()

	if uwc == nil {
		return
	}
	defer uwc.Close()
	if e != nil {
		dlg := dialog.NewError(e, appData.mainWindow)
		dlg.Show()
	}
	uwc.Write([]byte(runner_go))
}

func writeHelp(uwc fyne.URIWriteCloser, e error) {
	help_go := help_go()

	if uwc == nil {
		return
	}
	defer uwc.Close()
	if e != nil {
		dlg := dialog.NewError(e, appData.mainWindow)
		dlg.Show()
	}
	uwc.Write([]byte(help_go))
}

func runner_go() string {
	sb := strings.Builder{}
	sb.WriteString("// file generated by Boa Constructor from input script by " + appData.author.Text + "\n\n")
	sb.WriteString("package " + appData.pkg.Text + "\n")

	sb.WriteString(`
import (
	"log"
	"io"
	"github.com/westarver/boa"
)

func Run(w io.Writer) int {
	exitCode := 0
	cli := boa.FromJSON(jsonStr())
	if cli == nil {
		log.Println("unable to parse input")) 
		return -1
	}
	`)
	for _, f := range flagInfo.flags {
		flagvar := strings.TrimPrefix(f.Name, "--")
		boolvar := flagvar + "Exist"
		fncall := boa.TypeToString(f.ParamType)
		if f.ParamCount != 0 && f.ParamCount != 1 {
			fncall += "Slice"
		}

		flagsec := "\n\t" + flagvar + ", " + boolvar + " := cli." + fncall + `("` + flagvar + `") // ` + f.ShortHelp + "\n"
		sb.WriteString(flagsec)
	}

	hlpsec := `
	topic, helpExist := cli.String("help")
	if hlp {
		if len(topic) > 0 {
			ShowHelp(w, cli.Help(topic))
			return 0
		}
		ShowHelp(w)
		return 0
	}

`
	sb.WriteString(hlpsec)

	var boolvars []string

	for _, c := range cmdInfo.commands {
		if c.Name == "help" {
			continue // already done
		}

		boolvar := c.Name + "Exist"
		boolvars = append(boolvars, boolvar)
		fncall := boa.TypeToString(c.ParamType)
		if c.ParamCount != 0 && c.ParamCount != 1 {
			fncall += "Slice"
		}

		var implStr string
		if c.Extra == "" {
			implStr = ` {
		// TODO: implement ` + c.Name + `
		log.Println("` + c.Name + ` not implemented")
	}
	`
		} else {
			implStr = ` {
		` + c.Extra + `					
	}
	`
		}
		middle := "\n\t" + c.Name + ", " + boolvar + " := cli." + fncall + `("` + c.Name + `") // ` + c.ShortHelp + `
	if ` + boolvar + implStr
		sb.WriteString(middle)
	}

	var condition string
	for _, b := range boolvars {
		condition += " !" + b + " &&"
	}
	condition = strings.TrimSuffix(condition, " &&")
	ending := "\n\tif !helpExist &&" + condition + ` { // default command is help
		ShowHelp(w)
		return 0
	}

	return exitCode
}
`
	sb.WriteString(ending)
	return sb.String()
}

func help_go() string {
	sb := strings.Builder{}
	sb.WriteString("// file generated by Boa Constructor from input script by " + appData.author.Text + "\n\n")
	sb.WriteString("package " + appData.pkg.Text + "\n")
	jsonStr := `
import (
	"fmt"
	"io"
	"os"
)

// jsonStr returns a string that is passed to boa to obtain
// the map of command line items actually passed to this app
func jsonStr() string {
	jStr := ` + "`" + string(slice2json()) + "`" + `

	return jStr
}

`
	sb.WriteString(jsonStr + "\n")

	help := `func ShowHelp(w io.Writer, topic ...string) {
	help := ` + "`" + clean() + "`" + `

	if len(topic) != 0 {
		fmt.Fprintf(w, "%s\n", topic[0])
		return 0
	}
	 
	fmt.Fprintln(w, help)
}
`
	sb.WriteString(help + "\n")
	return sb.String()
}

func main_go() string {
	sb := strings.Builder{}
	sb.WriteString("// file generated by Boa Constructor from input script by " + appData.author.Text + "\n\n")
	sb.WriteString("package main\n")
	mainfunc := `
import (
	"os"
` + `	"` + appData.pkg.Text + `"
)
	
func main() {
	os.Exit(` + appData.pkg.Text + `.Run(os.Stderr))
}
`
	sb.WriteString(mainfunc)
	return sb.String()
}

// // usage returns a string that is passed to boa to obtain
// // the map of command line items actually passed to this app
// func usage() string {
// 	usage := ` + "`" + previewString() + "`" + `
// 	return usage
// }
