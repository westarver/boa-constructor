package generate

import (
	"fmt"
	"os"
	"path/filepath"

	"strings"

	clargs "github.com/westarver/boa-constructor/clargs"

	dlg "github.com/sqweek/dialog"
	"github.com/westarver/boa"
	data "github.com/westarver/boa-constructor/appdata"
	"github.com/westarver/boa-constructor/io"
)

func generateRun() string {
	file, err := dlg.File().Filter("go files", "go").Title("Generate runner.go").SetStartFile("runcli.go").Save()
	if err == nil {
		writeRunner(file)
	}
	run := filepath.Base(file)
	i := strings.LastIndex(run, ".")
	run = run[:i]
	run = strings.Title(run)

	return run
}

func generateMain(run string) {
	file, err := dlg.File().Filter("go files", "go").Title("Generate main.go").SetStartFile("main.go").Save()
	if err == nil {
		writeMain(file, run)
	}
}

func generateHelp() {
	file, err := dlg.File().Filter("go files", "go").Title("Generate help.go").SetStartFile("help.go").Save()
	if err == nil {
		writeHelp(file)
	}
}

func writeMain(file, run string) error {
	w, err := os.OpenFile(file, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
	if err != nil {
		return err
	}
	defer w.Close()

	fmt.Fprint(w, main_go(run))
	return nil
}

func writeRunner(file string) error {
	w, err := os.OpenFile(file, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
	if err != nil {
		return err
	}
	defer w.Close()

	fmt.Fprint(w, runner_go())
	return nil
}

func writeHelp(file string) error {
	w, err := os.OpenFile(file, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
	if err != nil {
		return err
	}
	defer w.Close()

	fmt.Fprint(w, help_go())
	return nil
}

const RunFunc1 = `
import (
	"fmt"
	"io"
	"os"

	"github.com/westarver/boa"
)
`
const RunFunc2 = `
func Runcli(w io.Writer) int {
	cli := boa.FromJSON(jsonBytes(), os.Args)
	if cli == nil {
		fmt.Fprintf(w, "%s\n", "unable to obtain cli object")
		return -1
	}
`

const cliHelpSection = `
	topic, helpExist := cli.String("help")
	if helpExist {
		if len(topic) == 0 {
			%[1]s.ShowHelp(w)
			return 0
		}
		%[1]s.ShowHelp(w, cli.Help(topic))

		return 0
	}
`
const runEnding = `
	if !helpExist && %s { 
		%s.ShowHelp(w)
		return 0
	}

	return 0
}
`
const jsonBytesFunc = `

// jsonBytes contains all of the commands and flags recognized by
// this app. Calling boa.FromJSON(jsonBytes(), os.Args) returns the 
// map of command line items actually passed to this app instance.
func jsonBytes() []byte {
	return []byte (` + "`%s`" + `)
}
`

func json() ([]byte, error) {
	jbyte, err := io.Args2json(data.GlobalData.AppName.Text, data.GlobalData.ImportPath.Text, data.GlobalData.HelpPkg.Text, data.GlobalData.RunPkg.Text, data.GlobalData.Author.Text, data.GlobalData.More.Text)
	if err != nil {
		return nil, err
	}
	return jbyte, nil
}

const recognitionBlockUnImpl = `	
	%[1]s
	%[2]s, %[3]s := cli.%[4]s("%[5]s")
	if %[3]s {%[6]s
		// TODO: implement "%[5]s"	
		_%[2]s := %[2]s
		fmt.Fprintf(w, "command line argument %[7]s not implemented", _%[2]s)
	}
`

const recognitionBlockImpl = `	
	%[1]s
	%[2]s, %[3]s := cli.%[4]s("%[5]s")
	if %[3]s {%[6]s
		%[7]s
	}
`

func implArg(arg *clargs.CommandLineArg, nest int) (string, string) {
	var indent = strings.Repeat("\t", nest)

	argName := strings.TrimPrefix(arg.Name(), "--")
	boolvar := argName + "Exist"

	typeString := strings.Replace(boa.TypeToString(arg.ParamType()), " ", "", -1)
	if arg.ParamCount() != 0 && arg.ParamCount() != 1 && arg.ParamCount() != -1 {
		typeString += "Slice"
	}

	var nestedBlock string
	if arg.Children() != nil {
		for _, ch := range arg.Children() {
			arg := data.GlobalData.MainList.Get(ch)
			if arg != nil {
				nestedBlock, _ = implArg(arg, nest+1)
			}
		}
		var indentedBlock []string
		nst := strings.Split(nestedBlock, "\n")
		for _, n := range nst {
			n := indent + n
			indentedBlock = append(indentedBlock, n)
		}
		nestedBlock = strings.Join(indentedBlock, "\n")
	}

	sub1 := "// " + arg.ShortHelp()
	sub2 := argName
	sub3 := boolvar
	sub4 := typeString
	sub5 := arg.Name()
	sub6 := nestedBlock
	sub7 := "%s"
	if arg.RunCode() == "" {
		return fmt.Sprintf(indent+recognitionBlockUnImpl, sub1, sub2, sub3, sub4, sub5, sub6, sub7), boolvar
	}
	sub7 = arg.RunCode()
	return fmt.Sprintf(indent+recognitionBlockImpl, sub1, sub2, sub3, sub4, sub5, sub6, sub7), boolvar
}

func runner_go() string {
	sb := strings.Builder{}
	sb.WriteString("// file generated by Boa Constructor from input by " + data.GlobalData.Author.Text + "\n\n")
	sb.WriteString("package " + data.GlobalData.RunPkg.Text + "\n")

	sb.WriteString(RunFunc1)

	jb, err := json()
	if err != nil {
		return ""
	}
	sb.WriteString(fmt.Sprintf(jsonBytesFunc, jb))
	sb.WriteString(RunFunc2)

	var middle, boolvar string
	var boolvars []string
	names := data.GlobalData.MainList.Names()
	for _, n := range names {
		arg := data.GlobalData.MainList.Get(n)
		if arg == nil {
			continue
		}
		if arg.Name() == "help" {
			continue // already done
		}
		if arg.Parent() != "" { // don't generate code at top level for sub commands
			continue
		}
		middle, boolvar = implArg(arg, 1)
		boolvars = append(boolvars, boolvar)
		sb.WriteString(middle)
	}

	if !data.GlobalData.IsGui {
		var condition string
		sb.WriteString(fmt.Sprintf(cliHelpSection, data.GlobalData.HelpPkg.Text))
		for _, b := range boolvars {
			condition += " !" + b + " &&"
		}
		condition = strings.TrimSuffix(condition, " &&")

		sb.WriteString(fmt.Sprintf(runEnding, condition, data.GlobalData.HelpPkg.Text))
	} else {
		sb.WriteString("\treturn 0\n}")
	}
	return sb.String()
}

const helpimports = `
import(
	"io"
	"fmt"
)

`
const cliBody = `
func ShowHelp (w io.Writer, topic ...string) {
	if len(topic) == 0 {
		fmt.Fprintf(w, Usage)
		return
	}
	 fmt.Fprintf(w, "\n%s\n\n", topic[0])	
}
`
const usage = `
const Usage = 
    `

func help_go() string {
	sb := strings.Builder{}
	sb.WriteString("// file generated by Boa Constructor from input script by " + data.GlobalData.Author.Text + "\n\n")
	sb.WriteString("package " + data.GlobalData.HelpPkg.Text)
	if !data.GlobalData.IsGui {
		sb.WriteString(helpimports)
	}

	preview := strings.Trim(data.GlobalData.Preview.Text, "\n")

	if data.GlobalData.MdHelp {
		preview = convertToMd(preview)
	}
	use := usage + "`" + preview + "`" + "\n\n"

	sb.WriteString(use)

	if !data.GlobalData.IsGui {
		sb.WriteString(cliBody)
	} else {
		sb.WriteString("func ShowHelp() string {\n\t return Usage\n}\n\n")
	}

	return sb.String()
}

const mainfunc = `
import (
	"os"
 	"%s"
)
	
func main() {
	os.Exit(%s.%s(os.Stderr))
}
`

// main is not normally generated for a GUI app
func main_go(run string) string {
	importpath := data.TruncateImportPath()
	sb := strings.Builder{}
	sb.WriteString("// file generated by Boa Constructor from input script by " + data.GlobalData.Author.Text + "\n\n")
	sb.WriteString("package main\n")
	runpkg := strings.Trim(data.GlobalData.RunPkg.Text, " \t\n")
	mainfn := fmt.Sprintf(mainfunc, importpath+"/"+runpkg, runpkg, run)
	sb.WriteString(mainfn)
	return sb.String()
}

func ConfirmGen() {
	var run string
	ok := dlg.Message("%s", `Boa will now attempt to write the run 
	source file to the path you choose.`).Title("Write run.go").YesNo()
	if ok {
		run = generateRun()
	}

	//if !data.GlobalData.IsGui {
	ok = dlg.Message("%s", `Boa will now attempt to write the main
	   source file to the path you choose.`).Title("Write main.go").YesNo()
	if ok {
		generateMain(run)
	}
	//}

	ok = dlg.Message("%s", `Boa will now attempt to write the help 
	source file to the path you choose.`).Title("Write help.go").YesNo()
	if ok {
		generateHelp()
	}
}

func convertToMd(preview string) string {
	sl := strings.Split(preview, "\n")
	//foundLong := false
	for i, s := range sl {
		if strings.HasPrefix(s, "\tUsage") {
			sl[i] = strings.Replace(s, "\tUsage", "\n##\t  Usage", 1)
			continue
		}
		if strings.HasPrefix(s, "\t"+data.GlobalData.AppName.Text) {
			sl[i] = strings.Replace(s, "\t"+data.GlobalData.AppName.Text, "###\t"+data.GlobalData.AppName.Text, 1)
			continue
		}
		if strings.HasPrefix(s, "\tCommand") {
			sl[i] = strings.Replace(s, "\tCommand", "####\t  Command", 1)
			continue
		}
		if strings.HasPrefix(s, "Long Descriptions:") {
			sl[i] = strings.Replace(s, "Long Descriptions:", "##### Long Descriptions:", 1)
			//foundLong = true
			continue
		}
		if strings.HasPrefix(s, "More:") {
			sl[i] = strings.Replace(s, "More:", "##### More:", 1)
			break
		}
		// if strings.Trim(s, " \t\n") == "" {
		// 	sl[i] = "\n" + s
		// 	continue
		// }
		// if strings.Trim(s, " \t\n") == "|" {
		// 	sl[i] = "\n" + s
		// 	continue
		// }
		// if !foundLong {
		// 	sl[i] = "-" + s
		// 	continue
		// }
	}

	md := strings.Join(sl, "\n")
	fmt.Println(md)
	return md
}
